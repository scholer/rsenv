
# Copyright 2015 Rasmus Sorensen

# pylint: disable=C0103

"""
Resources:

NEB:
* http://nc2.neb.com/NEBcutter2/
* http://rebase.neb.com/rebase/
* https://www.neb.com/tools-and-resources/interactive-tools/enzyme-finder
https://www.neb.com/sitecore/content/nebsg/home/tools-and-resources/selection-charts/time-saver-qualified-restriction-enzymes
https://www.neb.com/tools-and-resources/usage-guidelines/nebuffer-performance-chart-with-restriction-enzymes
https://www.neb.com/tools-and-resources/selection-charts/alphabetized-list-of-recognition-specificities
http://www.neb.uk.com/Product_Overview/high_fidelity.asp
https://www.neb.com/tools-and-resources/interactive-tools/enzyme-finder?searchType=9  # HF Restriction Endonucleases

Other:
* http://www.ualberta.ca/~stothard/javascript/index.html

"""


import requests


def post_data(sequence, seq_name=None, proj_token=None):
    """
    Simulates post request with form nc2.neb.com/NEBcutter2/
    """
    # <form name="mainForm" method="post" action="enzcut.php" enctype="multipart/form-data">
    action_url = "http://nc2.neb.com/NEBcutter2/enzcut.php"

    # data: post data as dict
    # See also http://nc2.neb.com/NEBcutter2/index_options.php
    data = {'referer': "",      # <input type="hidden" name="referer" value="">
            # In addition to Type II and commercially available Type III enzymes, also look for:
            'add_type13': '0',  # Type I & III enzymes
            'add_homing': '0',  # Homing endonucleases
            'add_nick': '0',    # Nicking enzymes
            # ------------------------------------------------
            'no_cpg': '0',      # Ignore CpG methylation
            'no_dam': '0',      # Ignore Dam methylation
            'no_dcm': '0',      # Ignore Dcm methylation
            'no_ecobi': '0',    # Ignore EcoBI methylation
            'no_ecoki': '0',    # Ignore EcoKI methylation
            # ------------------------------------------------
            'cut_from': '0',    # Only use this part of the sequence (start)
            'cut_to': '0',      # Only use this part of the sequence (end)
            'gcode': '11',      # Genetic code to use when searching for ORFs: (Value 1-23)
            'seqisfrag': '0',   # Sequence is a fragment (checkbox)
            # ------------------------------------------------
            'enz_suppl': '0',   # 0 = NEB, 1=All commercial, 2=All, 3=All defined, 4=Only defined.
            'circular': '0',    # 0=Linear, 1=Circular
            'min_orf': '100',   # Minimum ORF length to display: <input name="min_orf" size=5 maxlength=5 value="100"> a.a.</td>
            'username': '0',    # Name of sequence: (optional), <input name="username" size=20 maxlength=20>
            'name': '0',        # Token, should be (pseudo) randomized alá name=63ca7b3d-   # base64 ? 8 hex values + '-'
            'oliseq': [],        # List of pre-defined oligo sequences
            'sequence': "",     # Input sequence, <textarea name="sequence" rows="8" cols="70"></textarea>
            # '<input type=submit value=" Submit ">     # Submit button. Does not have a field?
            # local file, <input type=file name=seqfile>
            }

    # A new unique name can also be generated by querying "http://nc2.neb.com/NEBcutter2/index.php"
    # [line for line in r.text.split('\n') if 'name=name' in line]

    data['sequence'] = sequence
    data['name'] = proj_token or "".join(random.choice("1234567890abcdef") for i in range(8)) + '-'
    data['username'] = seq_name or "rasmus01"
    # "name" is actually <proj_token>+<username>, e.g. c8da0e52-rasmus01
    # That's why the dash '-' is appended to <proj_token>.
    print("Project token:", data['name'])
    print("Sequence name:", data['username'])
    print("Sequence:     ", sequence)

    r = requests.post(action_url, data=data)
    # The result page at http://nc2.neb.com/NEBcutter2/enzcut.php is not very informative,
    # it redirects to http://nc2.neb.com/NEBcutter2/cutshow.php but
    # it is pretty hard to extract information from that. :-/
    # The list page listbycuts.php?name=c8da0e52-rasmus01&numcuts=1
    # has a table that is slightly better. I'm sure I can parse it with BeautifulSoup,
    # but it would be nicer to just have a REST interface that just returned some easy-to-load json.

    return r
