"""


Download completed NuPack job files.


Usage:

    $ python -m rsenv.web.nupack.nupack_download_job jobtokenslist.yaml --unzip

    jobtokenslist.yaml is a file with job urls/tokens/jobids,
    as generated by the `nupack_batch_submit` module/script (specifying `--outputfmt YAML` [the default]).



"""

import os
import re
import argparse
from pprint import pprint
import zipfile
import yaml
import requests

NUPACK_DL_JOB_URL = 'http://nupack.org/partition/download_tar/'
NUPACK_DL_JOB_URI_FMT = 'http://nupack.org/partition/download_tar/{jobid}?token={token}'
TOKEN_REGEX = re.compile(r"token=(\w+)")


def load_yaml(filepath):
    """ Load yaml from filepath (reference function). """
    with open(filepath) as fp:
        r = yaml.load(fp)
    return r


def token_from_url(url):
    match = TOKEN_REGEX.search(url)
    token = match.group(1) if match else None
    return token


def jobid_from_url(url):
    from urllib.parse import urlparse
    url_parts = urlparse(url)
    job_id = url_parts.path.strip("/").split('/')[-1]
    try:
        return int(job_id)
    except ValueError:
        return None


def download_jobs_from_file(
        joblistfile,
        session=None,
        outputdir=None,
        use_header_fn=True, outputfnfmt="nupack_{jobid}.zip", verbose=1):
    """"""
    if verbose is None:
        verbose = 1
    if session is None:
        session = requests.session()

    if isinstance(joblistfile, list):
        jobres = joblistfile
    else:
        if verbose and verbose > 1:
            print("\nReading jobs from file:", joblistfile)
        jobres = load_yaml(joblistfile)

    n_jobs = len(jobres)
    if verbose and verbose > 0:
        print("\nDownloading %s jobs..." % (n_jobs,))

    filenames = []

    for i, job in enumerate(jobres):
        if 'jobid' not in job:
            job['jobid'] = jobid_from_url(job['url'])
        if 'token' not in job:
            job['token'] = token_from_url(job['url'])

        if job['jobid'] is None or job['token'] is None:
            print("Error job %s of %s: token or jobid is None, skipping this job.")
            pprint(job)

        dlurl = NUPACK_DL_JOB_URI_FMT.format(**job)
        if verbose and verbose > 0:
            print("\nDownloading job {} of {} from url: {}".format(i, n_jobs, dlurl))
        res = session.get(dlurl)

        fn = outputfnfmt.format(**job)
        # Q: How does browsers know what filename to use? A: Generally, from the 'Content-Disposition' response header.
        if use_header_fn:
            try:
                d = res.headers['content-disposition']
                # regex alternatives:
                #`filename="?([\w\d\.]+)"?`, `filename=(.+)`, `filename="([^"]+)"`, filename="?(.+)"?
                fn = re.findall('filename="?([^"]+)"?', d)[0]  # re.findall("", d)
                fn = fn.strip('"')
                if verbose and verbose > 1:
                    print(" - Using filename from response header (content-disposition):", fn)
            except (KeyError, IndexError):
                pass
        if outputdir:
            fn = os.path.join(outputdir, fn)
        if verbose and verbose > 0:
            print(" - saving job to file:", fn)
        with open(fn, 'wb') as f:
            f.write(res.content)
        if verbose and verbose > 0:
            print(" - %s bytes written to file '%s'!" % (len(res.content), fn))
        filenames.append(fn)

    return filenames


def unzip_all(filenames, directory=".", verbose=0):
    if directory is None:
        directory = "."
    if not os.path.exists(directory):
        print("Making directory: %r" % (directory,))
        os.makedirs(directory)

    for fn in filenames:
        if verbose and verbose > 0:
            print("\nExtracting file %r (to directory %r):" % (fn, directory))
        zip_ref = zipfile.ZipFile(fn, 'r')
        zip_ref.extractall(directory)
        zip_ref.close()


def main(argv=None):
    """Main driver, executed when running this module as a script.

    Parse command line args and pass them to download_jobs_from_file().

    After downloading, unzip with `unzip <file>` (all zipped files use jobid as folder prefix).
    """
    argns, _ = parse_args(argv)
    # if argns.config:
    #     config.update(load_yaml(argns.jobparams))
    session = requests.Session()
    filenames = download_jobs_from_file(argns.joblistfile, session=session, verbose=argns.verbose)
    if argns.unzip:
        unzip_all(filenames, directory=argns.unzip_outputdir, verbose=argns.verbose+1)
    print("\nDONE!")
    return filenames


def parse_args(argv):
    """Parse command line arguments.
    """

    # Use ArgumentDefaultsHelpFormatter formatter class to display default argument values when printing help.
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--verbose', '-v', action="count", help="Increase verbosity.")
    parser.add_argument('--outputfnfmt', metavar="OUTPUT_FILENAMES_FORMAT", default="nupack_{jobid}.zip", help=(
        "Save downloaded jobs to files according to this filename."
    ))
    parser.add_argument('joblistfile', metavar="JOB_RESULT_FILE.yaml", help=(
        "Load tokens and job IDs from this file."))
    parser.add_argument('--unzip', action="store_true",
                        help="Unzip all zip files after downloading them.")
    parser.add_argument('--unzip-outputdir', default='.',
                        help="Unzip all zip files after downloading them.")

    return parser.parse_args(argv), parser


if __name__ == '__main__':
    main()
